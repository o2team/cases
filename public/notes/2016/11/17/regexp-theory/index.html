<!DOCTYPE html><html class="theme-lattice"><head><meta charset="utf-8"><title>正则表达式理论篇 | Aotu.io「凹凸实验室」</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="author" content="凹凸实验室"><meta name="designer" content="凹凸实验室"><meta name="rating" content="general"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="index, follow"><meta baidu-gxt-verify-token="2b74a5aea155a215abea8547f929190c"><meta name="keywords" content="回溯,RegExp方法,String方法,正则表达式,凹凸实验室,Aotu,前端开发,全栈开发,IOS开发,Android开发"><link rel="canonical" href="https://aotu.io/notes/2016/11/17/regexp-theory/index.html"><link rel="apple-touch-icon" sizes="57x57" href="/img/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="114x114" href="/img/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="72x72" href="/img/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="144x144" href="/img/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="60x60" href="/img/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="120x120" href="/img/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="152x152" href="/img/apple-touch-icon-152x152.png"><link rel="icon" type="image/png" href="/img/favicon-230x230.png" sizes="230x230"><link rel="icon" type="image/png" href="/img/android-chrome-192x192.png" sizes="192x192"><link rel="icon" type="image/png" href="/img/android-chrome-144x144.png" sizes="144x144"><link rel="icon" type="image/png" href="/img/favicon-96x96.png" sizes="96x96"><link rel="icon" type="image/png" href="/img/favicon-16x16.png" sizes="16x16"><link rel="icon" type="image/png" href="/img/favicon-32x32.png" sizes="32x32"><meta name="msapplication-TileColor" content="#2f83cd"><meta name="msapplication-TileImage" content="/img/mstile-144x144.png"><meta property="wb:webmaster" content="a1686eb81db284d5"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" href="/atom.xml" title="Aotu.io"><meta name="description" content="学习正则表达式的你们，有没有发现，一开始总是记不住语法。嗯，加深大家的印象的同时，我也是来找同道中人的。"><meta property="og:type" content="article"><meta property="og:title" content="正则表达式理论篇"><meta property="og:url" content="https://aotu.io/notes/2016/11/17/regexp-theory/index.html"><meta property="og:site_name" content="Aotu.io"><meta property="og:description" content="学习正则表达式的你们，有没有发现，一开始总是记不住语法。嗯，加深大家的印象的同时，我也是来找同道中人的。"><meta property="og:image" content="https://aotu.io//misc.aotu.io/Newcandy/2016-11-16-regexp-theory/match.png"><meta property="og:image" content="https://aotu.io//misc.aotu.io/Newcandy/2016-11-16-regexp-theory/exec_g.png"><meta property="og:image" content="https://aotu.io//misc.aotu.io/Newcandy/2016-11-16-regexp-theory/backtracking.png"><meta property="og:updated_time" content="2016-11-28T19:26:06.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="正则表达式理论篇"><meta name="twitter:description" content="学习正则表达式的你们，有没有发现，一开始总是记不住语法。嗯，加深大家的印象的同时，我也是来找同道中人的。"><meta name="twitter:image" content="https://aotu.io//misc.aotu.io/Newcandy/2016-11-16-regexp-theory/match.png"><meta name="twitter:site" content="o2circle"><script>var App={root:"/",isHome:!1,isCate:!1,isTag:!1}</script></head><body class="page-post-detail"><div class="mod-hd"><div class="grid"><div class="mod-logo"><a href="/index.html" title="Aotu.io">Aotu.io</a></div><span class="mod-hd-toggle" id="J_hdToggle"><i class="fa fa-bars"></i></span><div class="mod-hd-main"><div class="mod-hd-inner"><nav class="mod-nav"><ul class="mod-nav-list"><li class="main-nav-item"><a href="/index.html" class="main-nav-link">首页</a></li><li class="main-nav-item"><a href="/about/" class="main-nav-link">关于</a></li><li class="main-nav-item"><a href="/join/" class="main-nav-link">加入我们</a></li></ul></nav><div class="mod-search" id="J_search"><a class="fa fa-search mod-search-ico" id="J_searchTrigger" title="搜索"></a><form id="J_searchForm" method="get" class="mod-search-form" action="/search/"><input type="text" name="query" class="mod-search-ipt" id="J_searchInput" placeholder="搜索"></form></div></div></div></div></div><div class="mod-container"><div class="grid"><div class="mod-main typo"><article class="post"><div class="post-cover"><img src="//misc.aotu.io/Newcandy/2016-11-16-regexp-theory/cover_900x500.jpg" alt="正则表达式理论篇"></div><header class="post-hd"><h1 class="post-tit">正则表达式理论篇</h1><div class="post-meta">by <a target="_blank" href="https://github.com/Newcandy" class="post-author">暖暖</a> on <span>2016-11-17</span></div><p class="post-subtit" style="display:none"><i class="fa fa-quote-left"></i>总是记不住正则表达式的语法？我这就来加深你们的印象。</p><span style="display:none" id="busuanzi_value_page_pv"></span></header><div class="post-content"><p>学习正则表达式的你们，有没有发现，一开始总是记不住语法。嗯，加深大家的印象的同时，我也是来找同道中人的。</p><a id="more"></a><h2 id="首先你要记住它的名字" class="post-heading"><a href="#首先你要记住它的名字" class="headerlink" title="首先你要记住它的名字"></a>首先你要记住它的名字<a class="post-anchor" href="#首先你要记住它的名字" aria-hidden="true"></a></h2><p>正则表达式<br>regular expression<br>缩写 regexp 、regex 、egrep。</p><h2 id="正则表达式可以干嘛" class="post-heading"><a href="#正则表达式可以干嘛" class="headerlink" title="正则表达式可以干嘛"></a>正则表达式可以干嘛<a class="post-anchor" href="#正则表达式可以干嘛" aria-hidden="true"></a></h2><ul><li>数据验证。</li><li>复杂的字符串搜寻、替换。</li><li>基于模式匹配从字符串中提取子字符串。</li></ul><h2 id="概述" class="post-heading"><a href="#概述" class="headerlink" title="概述"></a>概述<a class="post-anchor" href="#概述" aria-hidden="true"></a></h2><p>正则表达式包括<strong>普通字符</strong>（例如，a 到 z 之间的字母）和<strong>特殊字符</strong>（称为“元字符”）。</p><p>若要匹配这些特殊字符，必须首先<strong>转义字符</strong>，即，在字符前面加反斜杠字符 <code>\</code>**。<br>例如，若要搜索 “+”文本字符，可使用表达式 <code>\+</code>。<br>但是大多数 特殊字符 在中括号表达式内出现时失去本来的意义，并恢复为普通字符。</p><h2 id="构造函数（四种写法）" class="post-heading"><a href="#构造函数（四种写法）" class="headerlink" title="构造函数（四种写法）"></a>构造函数（四种写法）<a class="post-anchor" href="#构造函数（四种写法）" aria-hidden="true"></a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'xyz'</span>, <span class="string">'i'</span>);  </div><div class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/xyz/i</span>); </div><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/xyz/i</span>; </div><div class="line"></div><div class="line"><span class="comment">// ES6的写法。ES5在第一个参数是正则时，不允许此时使用第二个参数，会报错。 </span></div><div class="line"><span class="comment">// 返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</span></div><div class="line"><span class="comment">// 下面代码返回”i”。</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/abc/ig</span>, <span class="string">'i'</span>).flags</div></pre></td></tr></table></figure><h2 id="用于模式匹配的String方法" class="post-heading"><a href="#用于模式匹配的String方法" class="headerlink" title="用于模式匹配的String方法"></a>用于模式匹配的String方法<a class="post-anchor" href="#用于模式匹配的String方法" aria-hidden="true"></a></h2><ul><li>String.search()<br>参数：要搜索的子字符串，或者一个正则表达式。<br>返回：<strong>第一个与参数匹配的子串的起始位置，如果找不到，返回-1</strong>。<br>说明：不支持全局搜索，如果参数是字符串，会先通过RegExp构造函数转换成正则表达式。</li></ul><ul><li>String.replace()<br>作用：查找并替换字符串。<br>第一个参数：字符串或正则表达式，<br>第二个参数：要进行替换的字符串，也可以是函数。<br>用法：</li></ul><p>替换文本中的$字符有特殊含义：<br></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$1</span>、<span class="variable">$2</span>、...、<span class="variable">$99</span> 与 regexp 中的第 <span class="number">1</span> 到第 <span class="number">99</span> 个子表达式相匹配的文本。</div><div class="line"><span class="variable">$&amp;</span>	与 regexp 相匹配的子串。</div><div class="line"><span class="variable">$`</span>	位于匹配子串左侧的文本。</div><div class="line"><span class="variable">$'</span>	位于匹配子串右侧的文本。</div><div class="line"><span class="variable">$$</span>	普通字符<span class="variable">$。</span></div></pre></td></tr></table></figure><p></p><p>如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'abc'</span>.replace(<span class="regexp">/b/g</span>, <span class="string">"&#123;$$$`$&amp;$'&#125;"</span>)</div><div class="line"><span class="regexp">//</span> 结果为 <span class="string">"a&#123;$abc&#125;c"</span>，即把b换成了&#123;<span class="variable">$abc</span>&#125;</div></pre></td></tr></table></figure><ul><li>String.match()<br>参数：要搜索的子字符串，或者一个正则表达式。<br>返回：<strong>一个由匹配结果组成的数组</strong>。</li></ul><p><strong>非全局检索</strong>：如果没有找到任何匹配的文本返回null；否则数组的第一个元素是匹配的字符串，剩下的是小括号中的子表达式，即a[n]中存放的是$n的内容。非全局检索返回三个属性：length 属性；index 属性声明的是匹配文本的第一个字符的位置；input 属性则存放的是被检索的字符串 string。</p><p><strong>全局检索</strong>：设置标志g则返回所有匹配子字符串，即不提供与子表达式相关的信息。没有 index 属性或 input 属性。</p><p><img src="//misc.aotu.io/Newcandy/2016-11-16-regexp-theory/match.png" alt="match"></p><ul><li>String.split()<br>作用：把一个字符串分割成字符串数组。<br>参数：正则表达式或字符串。<br>返回：子串组成的数组。</li></ul><h2 id="RegExp的方法" class="post-heading"><a href="#RegExp的方法" class="headerlink" title="RegExp的方法"></a>RegExp的方法<a class="post-anchor" href="#RegExp的方法" aria-hidden="true"></a></h2><ul><li>RegExpObject.exec()<br>参数：字符串。<br>返回：</li></ul><p><strong>非全局检索</strong>：与String.macth()非全局检索相同，返回一个数组或null。</p><p><strong>全局检索</strong>：尽管是全局匹配的正则表达式，但是exec方法只对指定的字符串进行一次匹配。但是可以反复调用来实现全局检索。在 RegExpObject 的lastIndex 属性指定的字符处开始检索字符串；匹配后，将更新lastIndex为匹配文本的最后一个字符的下一个位置；再也找不到匹配的文本时，将返回null，并把 lastIndex 属性重置为 0。</p><p>如：</p><p><img src="//misc.aotu.io/Newcandy/2016-11-16-regexp-theory/exec_g.png" alt="exec全局检索"></p><ul><li><p>RegExpObject.test()<br>参数：字符串。<br>返回：true或false。</p></li><li><p>RegExpObject.toString()<br>返回：字符串</p></li></ul><h2 id="字符" class="post-heading"><a href="#字符" class="headerlink" title="字符"></a>字符<a class="post-anchor" href="#字符" aria-hidden="true"></a></h2><p><code>|</code> 指示在两个或多个项之间进行选择。类似js中的或，又称<strong>分支条件</strong>。<br><code>/</code> 正则表达式模式的开始或结尾。<br><code>\</code> 反斜杠字符，用来转义。<br><code>-</code> 连字符 <strong>当且仅当在字符组[]的内部表示一个范围</strong>，比如[A-Z]就是表示范围从A到Z；如果需要在字符组里面表示普通字符-，放在字符组的开头即可。</p><p><code>.</code> 匹配除换行符 \n 之外的任何单个字符。<br><code>\d</code> 等价[0-9]，匹配0到9字符。<br><code>\D</code> 等价[^0-9]，与<code>\d</code>相反。<br><code>\w</code> 与以下任意字符匹配：A-Z、a-z、0-9 和下划线，等价于 [A-Za-z0-9<em>]。<br><code>\W</code> 与\w相反，即 [^A-Za-z0-9</em>]</p><h2 id="限定符（量词字符）" class="post-heading"><a href="#限定符（量词字符）" class="headerlink" title="限定符（量词字符）"></a>限定符（量词字符）<a class="post-anchor" href="#限定符（量词字符）" aria-hidden="true"></a></h2><p><strong>显示限定符</strong>位于大括号 {} 中，并包含指示出现次数上下限的数值；<code>*+?</code> 这三个字符属于<strong>单字符限定符</strong>：</p><p><code>{n}</code> 正好匹配 n 次。<br><code>{n,}</code> 至少匹配 n 次。<br><code>{n,m}</code> 匹配至少 n 次，至多 m 次。<br><code>*</code> 等价{0,}<br><code>+</code> 等价{1,}<br><code>?</code> 等价{0,1}</p><p>注意：</p><ul><li>显示限定符中，逗号和数字之间不能有空格，否则返回null！</li><li><strong>贪婪量词<code>*</code>和<code>+</code></strong>：javascript默认是贪婪匹配，也就是说匹配重复字符是尽可能多地匹配。</li><li><strong>惰性（最少重复匹配）量词<code>?</code></strong>：当进行非贪婪匹配，只需要在待匹配的字符后面跟随一个<code>?</code>即可。</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="keyword">reg</span> = /a+/;</div><div class="line"><span class="keyword">var</span> reg2 = /a+?/;</div><div class="line"><span class="keyword">var</span> str = 'aaab';</div><div class="line"></div><div class="line">str.<span class="built_in">match</span>(<span class="keyword">reg</span>); <span class="comment">// ["aaa"]</span></div><div class="line">str.<span class="built_in">match</span>(reg2); <span class="comment">// ["a"]</span></div></pre></td></tr></table></figure><h2 id="定位点（锚字符、边界）" class="post-heading"><a href="#定位点（锚字符、边界）" class="headerlink" title="定位点（锚字符、边界）"></a>定位点（锚字符、边界）<a class="post-anchor" href="#定位点（锚字符、边界）" aria-hidden="true"></a></h2><p><code>^</code> 匹配开始的位置。将 <code>^</code> 用作括号<code>[]</code>表达式中的第一个字符，则会对字符集求反。<br><code>$</code> 匹配结尾的位置。<br><code>\b</code> 与一个字边界匹配，如er\b 与“never”中的“er”匹配，但与“verb”中的“er”不匹配。<br><code>\B</code> 非边界字匹配。</p><h2 id="标记" class="post-heading"><a href="#标记" class="headerlink" title="标记"></a>标记<a class="post-anchor" href="#标记" aria-hidden="true"></a></h2><ul><li><p>中括号<code>[]</code> 字符组；标记括号表达式的开始和结尾，起到的作用是匹配这个或者匹配那个。<br><code>[...]</code> 匹配方括号内<strong>任意字符</strong>。很多字符在<code>[]</code>都会失去本来的意义：<code>[^...]</code>匹配不在方括号内的任意字符；<code>[?.]</code>匹配普通的问号和点号。<br><strong>但是不要滥用字符组这个失去意义的特性，比如不要使用<code>[.]</code>来代替<code>\:</code>转义点号，因为需要付出处理字符组的代价</strong>。</p></li><li><p>大括号<code>{}</code> 标记限定符表达式的开始和结尾。</p></li><li><p>小括号<code>()</code> 标记子表达式的开始和结尾，主要作用是分组，对内容进行区分。</p></li></ul><p><code>(模式)</code> 可以记住和这个模式匹配的匹配项（捕获分组）。<strong>不要滥用括号，如果不需要保存子表达式，可使用非捕获型括号<code>(?:)</code>来进行性能优化</strong>。<br><code>(?:模式)</code> 与模式 匹配，但不保存匹配项(非捕获分组)。<br><code>(?=模式)</code> 零宽正向先行断言，要求匹配与模式 匹配的搜索字符串。 找到一个匹配项后，将在匹配文本之前开始搜索下一个匹配项；但不会保存匹配项。<br><code>(?!模式)</code> 零宽负向先行断言，要求匹配与模式 不匹配的搜索字符串。 找到一个匹配项后，将在匹配文本之前开始搜索下一个匹配项；但不会保存匹配项。</p><p>有点晕？<br>好，换个说法。。。</p><p>先行断言<code>(?=模式)</code>：x只有在y前面才匹配，必须写成<code>/x(?=y)/</code>。 解释：找一个x，那个x的后面有y。<br>先行否定断言<code>(?!模式)</code>： x只有不在y前面才匹配，必须写成<code>/x(?!y)/</code>。 解释：找一个x，那个x的后面没有y。</p><p>稳住，又来了两个断言，来自ES7提案：</p><p>后行断言<code>(?&lt;=模式)</code>：与”先行断言”相反， x只有在y后面才匹配，必须写成<code>/(?&lt;=y)x/</code>。解释：找一个x，那个x的前面要有y。<br>后行否定断言<code>(?&lt;!模式)</code>： 与”先行否定断言“相反，x只有不在y后面才匹配，必须写成<code>/(?&lt;!y)x/</code>。 解释：找一个x，那个x的前面没有y。</p><p>可以看出，后行断言先匹配/(?&lt;=y)x/的x，然后再回到左边，匹配y的部分，即先右后左”的执行顺序。</p><p>零宽负向先行断言的例子：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var str=`<span class="javascript">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"o2"</span>&gt;</span></div><div class="line">            <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"o2_team"</span>&gt;</span></span></div><div class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/logo.jpg"</span> /&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`;</div><div class="line"><span class="regexp">//</span> &lt;(?!img) 表示找一个左尖括号&lt;，而且左尖括号&lt;的后面没有img字符；</div><div class="line"><span class="regexp">//</span> (?:.|\r|\n)*? 表示匹配左右尖括号&lt;&gt;里面的.或\r或\n，而且匹配次数为*?；(?:)不保存匹配项，提高性能；</div><div class="line"><span class="regexp">//</span> *后面加个? 表示非贪婪匹配。</div><div class="line">var reg = <span class="regexp">/&lt;(?!img)(?:.|\r|\n)*?&gt;/gi</span>;</div><div class="line">str.match(reg);</div><div class="line"><span class="regexp">//</span> 返回结果 [<span class="string">"&lt;div class="</span>o2<span class="string">"&gt;"</span>, <span class="string">"&lt;div class="</span>o2_team<span class="string">"&gt;"</span>, <span class="string">"&lt;/div&gt;"</span>, <span class="string">"&lt;/div&gt;"</span>]</div></pre></td></tr></table></figure><ul><li>反向引用：主要作用是给分组加上标识符\n。<br><code>\n</code> 表示引用字符，与第n个子表达式第一次匹配的字符相匹配。</li></ul><p>反向引用的例子，给MikeMike字符后加个单引号：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="keyword">reg</span> = /(Mike)(\1)(s)/;</div><div class="line"><span class="keyword">var</span> str = <span class="string">"MikeMikes"</span>;</div><div class="line">console.<span class="built_in">log</span>(str.<span class="keyword">replace</span>(<span class="keyword">reg</span>,<span class="string">"$1$2'$3"</span>));</div><div class="line"><span class="comment">// 返回结果 MikeMike's</span></div></pre></td></tr></table></figure><h2 id="非打印字符" class="post-heading"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符<a class="post-anchor" href="#非打印字符" aria-hidden="true"></a></h2><p><code>\s</code> 任何空白字符。即<code>[ \f\n\r\t\v]</code><br><code>\S</code> 任何非空白字符。<br><code>\t</code> Tab 字符(\u0009)。<br><code>\n</code> 换行符(\u000A)<br><code>\v</code> 垂直制表符(\u000B)。<br><code>\f</code> 换页符(\u000C)<br><code>\r</code> 回车符(\u000D)。</p><p>注意：<code>\n</code>和<code>\r</code>一起使用，即 <code>/[\r\n]/g</code>来匹配换行，因为unix扩展的系统以<code>\n</code>标志结尾，window以<code>\r\n</code>标志结尾。</p><h2 id="其他" class="post-heading"><a href="#其他" class="headerlink" title="其他"></a>其他<a class="post-anchor" href="#其他" aria-hidden="true"></a></h2><p><code>\cx</code> 匹配 x 指示的<strong>控制字符</strong>，要求x 的值必须在 A-Z 或 a-z 范围内。<br><code>\xn</code> 匹配n，n 是一个十六进制转义码，两位数长。<br><code>\un</code> 匹配 n，其中n 是以四位十六进制数表示的 Unicode 字符。</p><p><code>\nm</code> 或 \n 先尝试<strong>反向引用</strong>，不可则再尝试标识为一个八进制转义码。<br><code>\nml</code> 当n 是八进制数字 (0-3)，m 和 l 是八进制数字 (0-7) 时，匹配八进制转义码 nml。</p><h2 id="修饰符" class="post-heading"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符<a class="post-anchor" href="#修饰符" aria-hidden="true"></a></h2><ul><li><code>i</code> 执行不区分大小写的匹配。</li><li><code>g</code> 执行一个全局匹配，简而言之，即找到所有的匹配，而不是在找到第一个之后就停止。</li><li><code>m</code> 多行匹配模式，^匹配一行的开头和字符串的开头，$匹配行的结束和字符串的结束。</li></ul><p>ES6新增u和y修饰符：</p><ul><li><code>u</code>修饰符</li></ul><p>含义为“Unicode模式”，用来正确处理大于\uFFFF的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 加u修饰符以后，ES6就会识别<span class="symbol">\u</span>D83D<span class="symbol">\u</span>DC2A为一个字符，返回false。</div><div class="line">/^<span class="symbol">\u</span>D83D/u.test('<span class="symbol">\u</span>D83D<span class="symbol">\u</span>DC2A')  // false</div><div class="line">/^<span class="symbol">\u</span>D83D/.test('<span class="symbol">\u</span>D83D<span class="symbol">\u</span>DC2A') // true</div></pre></td></tr></table></figure><ul><li><code>y</code>修饰符</li></ul><p>与g修饰符都是全局匹配，不同之处在于：lastIndex属性指定每次搜索的开始位置，<code>g</code>修饰符从这个位置开始向后搜索，直到发现匹配为止；但是<code>y</code>修饰符要求必须在lastIndex指定的位置发现匹配，即<code>y</code>修饰符确保匹配必须从剩余的第一个位置开始，这也是“粘连”的涵义。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">/b/y</span>.exec(<span class="string">'aba'</span>)  <span class="regexp">//</span> null </div><div class="line"><span class="regexp">/b/</span>.exec(<span class="string">'aba'</span>)  <span class="regexp">//</span> [<span class="string">"b"</span>]</div></pre></td></tr></table></figure><h2 id="优先级顺序：" class="post-heading"><a href="#优先级顺序：" class="headerlink" title="优先级顺序："></a>优先级顺序：<a class="post-anchor" href="#优先级顺序：" aria-hidden="true"></a></h2><ol><li><code>\</code> 转义符</li><li><code>(), (?:), (?=), []</code> 括号和中括号</li><li><code>*、+、?、{n}、{n,}、{n,m}</code> 限定符</li><li>任何元字符<code>^、$、\</code> 定位点和序列</li><li><code>|</code> 替换</li></ol><h2 id="关于引擎" class="post-heading"><a href="#关于引擎" class="headerlink" title="关于引擎"></a>关于引擎<a class="post-anchor" href="#关于引擎" aria-hidden="true"></a></h2><p>JS 是 NFA 引擎。</p><p>NFA 引擎的特点：</p><ul><li><strong>以贪婪方式进行，尽可能匹配更多字符</strong>。</li><li><strong>急于邀功请赏，所以最左子正则式优先匹配成功，因此偶尔会错过最佳匹配结果（多选条件分支的情况）</strong>。</li></ul><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">'nfa</span> <span class="keyword">not</span>'.match(/nfa|nfa <span class="keyword">not</span>/)</div><div class="line">//  返回[<span class="string">"nfa"</span>]</div></pre></td></tr></table></figure><ul><li><strong>回溯（backtracking），导致速度慢</strong>。</li></ul><p>举个贪婪与回溯结合的例子：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">"AB01CD23CD45CEff"</span>.match(<span class="string">'AB.*CD'</span>)</div><div class="line"><span class="regexp">//</span> 返回 [<span class="string">"AB01CD23CD"</span>]</div></pre></td></tr></table></figure><p>匹配顺序如图所示：</p><p><img src="//misc.aotu.io/Newcandy/2016-11-16-regexp-theory/backtracking.png" alt="match"></p><h2 id="参考" class="post-heading"><a href="#参考" class="headerlink" title="参考"></a>参考<a class="post-anchor" href="#参考" aria-hidden="true"></a></h2><p>MDN<br>w3school<br><a href="http://es6.ruanyifeng.com/#docs/regex" target="_blank" rel="external">http://es6.ruanyifeng.com/#docs/regex</a><br><a href="http://imweb.io/topic/56e804ef1a5f05dc50643106" target="_blank" rel="external">http://imweb.io/topic/56e804ef1a5f05dc50643106</a><br><a href="http://www.cnblogs.com/deerchao/archive/2006/08/24/zhengzhe30fengzhongjiaocheng.html" target="_blank" rel="external">http://www.cnblogs.com/deerchao/archive/2006/08/24/zhengzhe30fengzhongjiaocheng.html</a><br><a href="http://www.cnblogs.com/hustskyking/p/how-regular-expressions-work.html" target="_blank" rel="external">http://www.cnblogs.com/hustskyking/p/how-regular-expressions-work.html</a></p><div class="post-tags" style="display:none"><a href="/tags/正则表达式/">正则表达式</a> <a href="/tags/String方法/">String方法</a> <a href="/tags/RegExp方法/">RegExp方法</a> <a href="/tags/回溯/">回溯</a></div><div class="post-categories" style="display:none"><a href="/cates/Web开发/">Web开发</a></div><div class="post-announce">感谢您的阅读，本文由 <a href="//aotu.io">凹凸实验室</a> 版权所有。如若转载，请注明出处：凹凸实验室（<a href="https://aotu.io/notes/2016/11/17/regexp-theory/">https://aotu.io/notes/2016/11/17/regexp-theory/</a>）</div><div class="post-revision"><i class="fa fa-clock-o"></i> <time class="post-updated" datetime="2016-11-28T19:26:06.000Z">上次更新：2016-11-29 03:26:06</time></div></div><div class="post-nav"><div class="post-nav-next"><a href="/notes/2016/11/21/liteo2-app-tarots/" title="「塔罗牌」 - 轻氧 V1.4 尝鲜体验邀请">「塔罗牌」 - 轻氧 V1.4 尝鲜体验邀请 <i class="fa fa-chevron-right"></i></a></div><div class="post-nav-prev"><a href="/notes/2016/11/15/xcel/" title="XCel 项目总结 - Electron 与 Vue 的性能优化"><i class="fa fa-chevron-left"></i> XCel 项目总结 - Electron 与 Vue 的性能优化</a></div></div><div class="post-comments" id="comments"><div class="ds-thread" data-thread-key="bm90ZXMvMjAxNi8xMS8xNy9yZWdleHAtdGhlb3J5Lw==" data-title="正则表达式理论篇" data-url="https://aotu.io/notes/2016/11/17/regexp-theory/index.html"></div><script type="text/javascript">var duoshuoQuery={short_name:"aotu"};!function(){var t=document.createElement("script");t.id="duoshuo-script",t.type="text/javascript",t.async=!0,t.src=("https:"==document.location.protocol?"https:":"http:")+"//static.duoshuo.com/embed.js",t.charset="UTF-8",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(t)}()</script></div></article></div><aside class="mod-side" id="sidebar"><div class="mod-side-sec aotuwx"><img class="aotuwx-qrcode" src="/img/qrcode.jpg" alt="关注我们"><div class="aotuwx-slogan">每周五推送精选技术文章</div></div><div class="mod-side-sec works"><div class="mod-side-sec-hd"><h2>服务/产品</h2></div><div class="mod-side-sec-bd"><ul class="mod-side-list"><li><a href="//cases.aotu.io/mobi/maga.html" target="_blank" title="拇指期刊">拇指期刊</a></li><li><a href="//athena.aotu.io/" target="_blank" title="Athena">Athena</a></li><li><a href="//guide.aotu.io/" target="_blank" title="前端代码规范">前端代码规范</a></li><li><a href="//halojs.aotu.io/" target="_blank" title="HaloJS">HaloJS</a></li><li><a href="//sign.aotu.io/" target="_blank" title="邮件签名工具">邮件签名工具</a></li><li><a href="//mac.aotu.io/" target="_blank" title="MAC全栈环境">MAC全栈环境</a></li><li><a href="//xcel.aotu.io" target="_blank" title="Excel Filter">Excel Filter</a></li></ul></div></div><div class="mod-side-sec favlinks"><div class="mod-side-sec-hd"><h2>友情链接</h2></div><div class="mod-side-sec-bd"><ul class="mod-side-list"><li><a href="https://jdc.jd.com" target="_blank" title="京东设计中心">JDC京东设计中心</a></li><li><a href="http://fex.baidu.com" target="_blank" title="百度Web前端研发部">百度FEX</a></li><li><a href="http://taobaofed.org" target="_blank" title="淘宝前端团队">淘宝FED</a></li><li><a href="http://tgideas.qq.com" target="_blank" title="腾讯互娱设计中心">TGIdeas</a></li><li><a href="http://isux.tencent.com" target="_blank" title="腾讯SNG设计中心">ISUX</a></li><li><a href="http://cdc.tencent.com" target="_blank" title="腾讯用户研究与体验设计中心">CDC</a></li><li><a href="http://ued.ctrip.com" target="_blank" title="携程设计委员会">携程UED</a></li></ul></div></div></aside></div></div><div class="mod-backtop" id="backTop"><i class="fa fa-long-arrow-up"></i></div><footer class="mod-ft" id="footer"><div class="grid"><ul class="mod-ft-links"><li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li><li><a href="https://github.com/o2team/o2team.github.io" target="_blank"><i class="fa fa-github-alt"></i></a></li></ul><div class="mod-ft-sec mod-ft-copyright"><p>Designed by <a href="http://aotu.io" target="_blank">凹凸实验室</a> @<a target="_blank" href="http://jdc.jd.com">京东用户体验设计部</a></p><p>Copyright &copy; 2016. All Rights Reserved.</p><p><a href="http://www.miibeian.gov.cn/" target="_blank">粤ICP备15077732号-2</a></p></div></div></footer><script src="/js/bundle/core.js"></script><script src="/js/post_wx_share.js"></script><script>!function(){var t=document.createElement("script"),s=window.location.protocol.split(":")[0];"https"===s?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="http://push.zhanzhang.baidu.com/push.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?e850b980d029480b092fdd7503c3f8de";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><style>#cnzz_stat_icon_1258539944{display:none}</style><script type="text/javascript">var cnzz_protocol="https:"==document.location.protocol?" https://":" http://";document.write(unescape("%3Cspan id='cnzz_stat_icon_1258539944'%3E%3C/span%3E%3Cscript src='"+cnzz_protocol+"s11.cnzz.com/z_stat.php%3Fid%3D1258539944' type='text/javascript'%3E%3C/script%3E"))</script></body></html>